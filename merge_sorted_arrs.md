##问题

给定两个排序好的数组A和B,将A和B合并成一个排序数组.		

假设A拥有足够空间,需要将B和A合并成A,不使用额外的内存空间.		

##想法		

假设数组都是升序排列的.可以采用如下的方法实现合并:		

对每个B中的元素B[i],遍历A,找出B[i]应该插入的位置j.将A中j位置开始的所有元素都向后移一位,在j位置插入B[i].而后取出B的下一个元素,当然此时的便利位置应该从A数组位置j+1开始.如此往复知道B中所有元素都插入到A中.		

例如:A=[1,2,4,7],B=[-1,3,5]		

(1) B[0]=-1,在A中插入位置loc=0,插入后A=[-1,1,2,4,7],B=[3,5].		
(2) B[1]=3,注意,这里不应该是从A起始位置开始便利,应该是从B[0]插入位置的下一个位置loc+1开始遍历,插入位置loc=3,插入后A=[-1,1,2,3,4,7],B=[5].		
(3)B[2]=5,从A的下标loc+1=4开始遍历,找到元素的插入位置loc=5,插入后A=[-1,1,2,3,4,5,7],B=[],结束.		

从实现思想可以看出,对两个数组各遍历一遍,能实现排序.时间复杂度为O(m+n).


###更简单的想法		

A和B合并后的长度应该为m+n.定义index=m+n-1,分别从B和A的末尾开始遍历数组,将元素更大的那个插入A[index]位置.直到某一数组遍历结束.	

```C++
    void merge(int A[], int m, int B[], int n) {
        if(n==0)
            return ;
        int index = m+n-1;
        m=m-1;
        n=n-1;
        while(m>=0&&n>=0){
            if(A[m]>B[n])
                A[index--]=A[m--];
            else
                A[index--]=B[n--];
        }
        while(m>=0)
            A[index--]=A[m--];
        while(n>=0)
            A[index--]=B[n--];
        return;
    }		
```		

这种实现方法的思想更清晰,时间复杂度也为O(m+n).
